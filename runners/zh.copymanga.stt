(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.STTPackage = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LISTING_TYPES = exports.API_HEADERS = exports.API_URL = exports.BASE_URL = exports.LIMIT = exports.DECRYPT_KEY = exports.EXPLORE_COLLECTIONS = exports.getProperties = exports.THEME_OPTIONS = exports.REGION_OPTIONS = exports.STATUS_OPTIONS = exports.SORT_OPTIONS = void 0;
const daisuke_1 = require("@suwatte/daisuke");
exports.SORT_OPTIONS = [
    { title: "更新時間", id: "datetime_updated" },
    { title: "熱門", id: "popular" },
];
exports.STATUS_OPTIONS = [
    { title: "全部", id: "-1" },
    { title: "連載中", id: "0" },
    { title: "已完結", id: "1" },
    { title: "短篇", id: "2" },
];
exports.REGION_OPTIONS = [
    { title: "全部", id: "-1" },
    { title: "日漫", id: "0" },
    { title: "韓漫", id: "1" },
    { title: "美漫", id: "2" },
];
exports.THEME_OPTIONS = [
    { title: "全部", id: "" },
    { title: "愛情", id: "aiqing" },
    { title: "歡樂向", id: "huanlexiang" },
    { title: "冒險", id: "maoxian" },
    { title: "奇幻", id: "qihuan" },
    { title: "百合", id: "baihe" },
    { title: "校園", id: "xiaoyuan" },
    { title: "科幻", id: "kehuan" },
    { title: "東方", id: "dongfang" },
    { title: "耽美", id: "danmei" },
    { title: "生活", id: "shenghuo" },
    { title: "格鬥", id: "gedou" },
    { title: "輕小說", id: "qingxiaoshuo" },
    { title: "懸疑", id: "xuanyi" },
    { title: "其他", id: "qita" },
    { title: "神鬼", id: "shengui" },
    { title: "職場", id: "zhichang" },
    { title: "TL", id: "teenslove" },
    { title: "萌系", id: "mengxi" },
    { title: "治癒", id: "zhiyu" },
    { title: "長條", id: "changtiao" },
    { title: "四格", id: "sige" },
    { title: "節操", id: "jiecao" },
    { title: "艦娘", id: "jianniang" },
    { title: "競技", id: "jingji" },
    { title: "搞笑", id: "gaoxiao" },
    { title: "偽娘", id: "weiniang" },
    { title: "熱血", id: "rexue" },
    { title: "勵志", id: "lizhi" },
    { title: "性轉換", id: "xingzhuanhuan" },
    { title: "彩色", id: "COLOR" },
    { title: "後宮", id: "hougong" },
    { title: "美食", id: "meishi" },
    { title: "偵探", id: "zhentan" },
    { title: "AA", id: "aa" },
    { title: "音樂舞蹈", id: "yinyuewudao" },
    { title: "魔幻", id: "mohuan" },
    { title: "戰爭", id: "zhanzheng" },
    { title: "歷史", id: "lishi" },
    { title: "異世界", id: "yishijie" },
    { title: "驚悚", id: "jingsong" },
    { title: "機戰", id: "jizhan" },
    { title: "都市", id: "dushi" },
    { title: "穿越", id: "chuanyue" },
    { title: "恐怖", id: "kongbu" },
    { title: "C100", id: "comiket100" },
    { title: "重生", id: "chongsheng" },
    { title: "C99", id: "comiket99" },
    { title: "C101", id: "comiket101" },
    { title: "C97", id: "comiket97" },
    { title: "C96", id: "comiket96" },
    { title: "生存", id: "shengcun" },
    { title: "宅系", id: "zhaixi" },
    { title: "武俠", id: "wuxia" },
    { title: "C98", id: "C98" },
    { title: "C95", id: "comiket95" },
    { title: "FATE", id: "fate" },
    { title: "轉生", id: "zhuansheng" },
    { title: "無修正", id: "Uncensored" },
    { title: "仙俠", id: "xianxia" },
    { title: "LoveLive", id: "loveLive" },
];
const getProperties = () => {
    const properties = [];
    // Theme
    properties.push({
        id: "theme",
        title: "題材",
        tags: exports.THEME_OPTIONS,
    });
    // Status
    properties.push({
        id: "status",
        title: "狀態",
        tags: exports.STATUS_OPTIONS,
    });
    // Region
    properties.push({
        id: "region",
        title: "地區",
        tags: exports.REGION_OPTIONS,
    });
    return properties;
};
exports.getProperties = getProperties;
exports.EXPLORE_COLLECTIONS = [
    {
        id: "latest",
        title: "最新更新",
        style: daisuke_1.SectionStyle.PADDED_LIST,
    },
    {
        id: "popular",
        title: "熱門漫畫",
        style: daisuke_1.SectionStyle.INFO,
    },
];
// AES Decryption Key
exports.DECRYPT_KEY = "xxxmanga.woo.key";
// Default limit for manga per page
exports.LIMIT = 30;
// Base URLs
exports.BASE_URL = "https://www.mangacopy.com";
exports.API_URL = "https://api.mangacopy.com/api/v3";
// API Headers
exports.API_HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
    Referer: exports.BASE_URL,
    version: "2.3.6",
    platform: "3",
    region: "1",
    webp: "1",
};
// Listing types
exports.LISTING_TYPES = {
    DAY_RANK: "day",
    WEEK_RANK: "week",
    MONTH_RANK: "month",
    TOTAL_RANK: "total",
    RECS: "recs",
    NEWEST: "newest",
};

},{"@suwatte/daisuke":5}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Target = exports.info = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
exports.info = {
    id: "zh.copymanga",
    name: "拷贝漫画",
    version: 1.1,
    website: constants_1.BASE_URL,
    supportedLanguages: ["zh"],
    thumbnail: "copymanga.png",
    minSupportedAppVersion: "5.0",
    rating: daisuke_1.CatalogRating.MIXED,
};
class Target {
    info = exports.info;
    client = new daisuke_1.NetworkClientBuilder()
        .addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
        .addHeader("Referer", constants_1.BASE_URL)
        .addHeader("version", "2.3.6")
        .addHeader("platform", "3")
        .addHeader("region", "1")
        .addHeader("webp", "1")
        .build();
    // Get manga list based on filters and page
    async getDirectory(request) {
        const params = (0, utils_1.parseSearchRequest)(request);
        if (params.q) {
            return this.search(params.q, request.page || 1);
        }
        return this.browse(params);
    }
    // Search for manga
    async search(query, page) {
        const url = (0, utils_1.generateSearchUrl)(query, page);
        const response = await this.client.get(url);
        const data = JSON.parse(response.data);
        if (!data.results || !data.results.list) {
            return { results: [], isLastPage: true };
        }
        const mangaList = data.results.list;
        const hasMore = (0, utils_1.hasMorePages)(data.results);
        return (0, utils_1.mangaListToPageResult)(mangaList, hasMore);
    }
    // Browse manga with filters
    async browse(params) {
        const theme = params.theme || "";
        const top = params.region || "";
        const ordering = params.ordering || "-datetime_updated";
        const offset = params.offset || 0;
        const limit = params.limit || 50;
        const page = Math.floor(offset / limit) + 1;
        const url = (0, utils_1.generateExploreUrl)(theme, top, ordering, page);
        const response = await this.client.get(url);
        const data = JSON.parse(response.data);
        if (!data.results || !data.results.list) {
            return { results: [], isLastPage: true };
        }
        const mangaList = data.results.list;
        const hasMore = (0, utils_1.hasMorePages)(data.results);
        return (0, utils_1.mangaListToPageResult)(mangaList, hasMore);
    }
    // Get manga details
    async getContent(contentId) {
        const url = (0, utils_1.generateMangaDetailsUrl)(contentId);
        const response = await this.client.get(url);
        const data = JSON.parse(response.data);
        if (data.code !== 200) {
            throw new Error(`Failed to fetch manga details: ${data.message}`);
        }
        if (!data.results) {
            throw new Error(`Empty manga details: ${data.message}`);
        }
        const results = data.results;
        const info = [];
        const comic = results.comic;
        const cover = comic.cover ? comic.cover.replace(".328x422.jpg", "") : "";
        const title = comic.name || "";
        const additionalTitles = comic.alias
            ? comic.alias.split(",").map((alias) => alias.trim())
            : [];
        const creators = comic.author
            ? comic.author.map((author) => author.name)
            : [];
        const summary = comic.brief || "";
        const status = (0, utils_1.convertStatus)(comic.status.value);
        if (comic.popular) {
            info.push(`🔥熱度: ${comic.popular}`);
        }
        if (comic.datetime_updated) {
            info.push(`🗓最後更新: ${comic.datetime_updated}`);
        }
        const region = (0, utils_1.convertRegion)(comic.region.value);
        info.push((0, utils_1.regionToDisplay)(region));
        info.push(comic.reclass.display);
        const recommendedPanelMode = (0, utils_1.readingModeByRegion)(region);
        const themes = [];
        if (comic.theme) {
            comic.theme.forEach((theme) => {
                if (theme.name) {
                    themes.push({
                        id: theme.path_word || theme.name,
                        title: theme.name,
                    });
                }
            });
        }
        const isNSFW = comic.restrict.value === 0 ? false : true;
        return {
            title,
            additionalTitles,
            recommendedPanelMode,
            cover,
            creators,
            summary,
            status,
            info,
            webUrl: `${constants_1.BASE_URL}/comic/${contentId}`,
            isNSFW,
            properties: [
                {
                    id: "theme",
                    title: "題材",
                    tags: themes,
                },
            ],
        };
    }
    // Get chapter list for a manga
    async getChapters(contentId) {
        const url = (0, utils_1.generateChapterListUrl)(contentId);
        const response = await this.client.get(url);
        const resultsMatch = response.data.match(/"results":"([^"]+)"/);
        if (!resultsMatch || !resultsMatch[1]) {
            return [];
        }
        const encryptedResults = resultsMatch[1];
        const decryptedResults = (0, utils_1.decryptString)(encryptedResults);
        try {
            const chapterListData = JSON.parse(decryptedResults);
            return (0, utils_1.chapterGroupsToChapters)(chapterListData.groups, contentId);
        }
        catch (error) {
            console.error("Error parsing chapter list:", error);
            return [];
        }
    }
    // Get page list for a chapter
    async getChapterData(contentId, chapterId) {
        const url = (0, utils_1.generatePageListUrl)(contentId, chapterId);
        const response = await this.client.get(url);
        const data = JSON.parse(response.data);
        if (!data.results || !data.results.chapter) {
            return { pages: [] };
        }
        const chapter = data.results.chapter;
        const pageList = chapter.contents || [];
        // Use the image format from the API response
        const imageFormat = "jpg";
        const imageQuality = "c800x";
        const imageExt = `${imageQuality}.${imageFormat}`;
        const pages = pageList.map((page, index) => ({
            index,
            url: page.url,
        }));
        return { pages };
    }
    // Get directory config
    async getDirectoryConfig() {
        return {
            filters: [
                {
                    id: "theme",
                    title: "題材",
                    type: daisuke_1.FilterType.SELECT,
                    options: (0, constants_1.getProperties)().find((p) => p.id === "theme")?.tags || [],
                },
                {
                    id: "status",
                    title: "狀態",
                    type: daisuke_1.FilterType.SELECT,
                    options: (0, constants_1.getProperties)().find((p) => p.id === "status")?.tags || [],
                },
                {
                    id: "region",
                    title: "地區",
                    type: daisuke_1.FilterType.SELECT,
                    options: (0, constants_1.getProperties)().find((p) => p.id === "region")?.tags || [],
                },
            ],
            sort: {
                options: constants_1.SORT_OPTIONS,
                default: {
                    id: "datetime_updated",
                    ascending: false,
                },
            },
        };
    }
    // Get listing for a specific category
    async getListing(listing, page = 1) {
        let url;
        switch (listing.id) {
            case constants_1.LISTING_TYPES.DAY_RANK:
                url = (0, utils_1.generateRankUrl)(constants_1.LISTING_TYPES.DAY_RANK, page);
                break;
            case constants_1.LISTING_TYPES.WEEK_RANK:
                url = (0, utils_1.generateRankUrl)(constants_1.LISTING_TYPES.WEEK_RANK, page);
                break;
            case constants_1.LISTING_TYPES.MONTH_RANK:
                url = (0, utils_1.generateRankUrl)(constants_1.LISTING_TYPES.MONTH_RANK, page);
                break;
            case constants_1.LISTING_TYPES.TOTAL_RANK:
                url = (0, utils_1.generateRankUrl)(constants_1.LISTING_TYPES.TOTAL_RANK, page);
                break;
            case constants_1.LISTING_TYPES.RECS:
                url = (0, utils_1.generateRecsUrl)(page);
                break;
            case constants_1.LISTING_TYPES.NEWEST:
                url = (0, utils_1.generateNewestUrl)(page);
                break;
            default:
                return this.getDirectory({ page });
        }
        const response = await this.client.get(url);
        const data = JSON.parse(response.data);
        if (!data.results || !data.results.list) {
            return { results: [], isLastPage: true };
        }
        const mangaList = data.results.list;
        const hasMore = (0, utils_1.hasMorePages)(data.results);
        return (0, utils_1.mangaListToPageResult)(mangaList, hasMore);
    }
    // Get tags
    async getTags() {
        return (0, constants_1.getProperties)();
    }
    // Handle image requests
    async willRequestImage(url) {
        return (0, utils_1.createNetworkRequest)(url);
    }
}
exports.Target = Target;

},{"./constants":1,"./utils":4,"@suwatte/daisuke":5}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Region = exports.Status = exports.SearchType = void 0;
var SearchType;
(function (SearchType) {
    SearchType["All"] = "";
    SearchType["Title"] = "name";
    SearchType["Author"] = "author";
    SearchType["Translator"] = "local";
})(SearchType = exports.SearchType || (exports.SearchType = {}));
var Status;
(function (Status) {
    Status[Status["All"] = -1] = "All";
    Status[Status["Ongoing"] = 0] = "Ongoing";
    Status[Status["Completed"] = 1] = "Completed";
    Status[Status["OneShot"] = 2] = "OneShot";
})(Status = exports.Status || (exports.Status = {}));
var Region;
(function (Region) {
    Region[Region["All"] = -1] = "All";
    Region[Region["Japan"] = 0] = "Japan";
    Region[Region["Korea"] = 1] = "Korea";
    Region[Region["West"] = 2] = "West";
})(Region = exports.Region || (exports.Region = {}));

},{}],4:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasMorePages = exports.generatePageListUrl = exports.generateChapterListUrl = exports.generateMangaDetailsUrl = exports.generateNewestUrl = exports.generateRecsUrl = exports.generateRankUrl = exports.generateSearchUrl = exports.generateExploreUrl = exports.createNetworkRequest = exports.chapterGroupsToChapters = exports.getTimestampFromUuid = exports.parseChapterTitle = exports.readingModeByRegion = exports.regionToDisplay = exports.convertRegion = exports.convertStatus = exports.mangaListToPageResult = exports.mangaToHighlight = exports.parseSearchRequest = exports.decryptString = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const types_1 = require("./types");
const constants_1 = require("./constants");
const crypto_js_1 = __importDefault(require("crypto-js"));
const decryptString = (encryptedString) => {
    try {
        const iv = encryptedString.substring(0, 16);
        const hexCiphertext = encryptedString.substring(16);
        const key = crypto_js_1.default.enc.Utf8.parse(constants_1.DECRYPT_KEY);
        const ivBytes = crypto_js_1.default.enc.Utf8.parse(iv);
        const cipherParams = crypto_js_1.default.lib.CipherParams.create({
            ciphertext: crypto_js_1.default.enc.Hex.parse(hexCiphertext),
        });
        const decrypted = crypto_js_1.default.AES.decrypt(cipherParams, key, {
            iv: ivBytes,
            padding: crypto_js_1.default.pad.Pkcs7,
            mode: crypto_js_1.default.mode.CBC,
        });
        return decrypted.toString(crypto_js_1.default.enc.Utf8);
    }
    catch (error) {
        console.error("Decryption error:", error);
        throw new Error("Failed to decrypt data");
    }
};
exports.decryptString = decryptString;
// Parse search request to URL parameters
const parseSearchRequest = (request) => {
    const page = request.page ?? 1;
    const offset = (page - 1) * constants_1.LIMIT;
    const params = {
        limit: constants_1.LIMIT,
        offset,
    };
    if (request.query) {
        params.q = request.query;
    }
    if (request.filters) {
        const { theme, status, region } = request.filters;
        if (theme)
            params.theme = theme;
        if (status)
            params.status = status;
        if (region)
            params.region = region;
    }
    if (request.sort) {
        if (request.sort.ascending) {
            params.ordering = request.sort.id;
        }
        else {
            params.ordering = `-${request.sort.id}`;
        }
    }
    return params;
};
exports.parseSearchRequest = parseSearchRequest;
// Convert manga excerpt to highlight
const mangaToHighlight = (manga) => {
    return {
        id: manga.path_word,
        title: manga.name,
        cover: manga.cover.replace(".328x422.jpg", ""),
    };
};
exports.mangaToHighlight = mangaToHighlight;
// Convert manga list to page result
const mangaListToPageResult = (mangaList, hasMore) => {
    return {
        results: mangaList.map(exports.mangaToHighlight),
        isLastPage: !hasMore,
    };
};
exports.mangaListToPageResult = mangaListToPageResult;
// Convert status code to publication status
const convertStatus = (statusCode) => {
    switch (statusCode) {
        case types_1.Status.Ongoing:
            return daisuke_1.PublicationStatus.ONGOING;
        case types_1.Status.Completed:
        case types_1.Status.OneShot:
            return daisuke_1.PublicationStatus.COMPLETED;
        default:
            return daisuke_1.PublicationStatus.ONGOING; // Default to ONGOING if unknown
    }
};
exports.convertStatus = convertStatus;
const convertRegion = (region) => {
    switch (region) {
        case types_1.Region.Japan:
            return types_1.Region.Japan;
        case types_1.Region.Korea:
            return types_1.Region.Korea;
        case types_1.Region.West:
            return types_1.Region.West;
        default:
            return types_1.Region.Japan;
    }
};
exports.convertRegion = convertRegion;
const regionToDisplay = (region) => {
    switch (region) {
        case types_1.Region.Japan:
            return "日漫";
        case types_1.Region.Korea:
            return "韓漫";
        case types_1.Region.West:
            return "美漫";
        default:
            return "其它";
    }
};
exports.regionToDisplay = regionToDisplay;
const readingModeByRegion = (region) => {
    switch (region) {
        case types_1.Region.Japan:
            return daisuke_1.ReadingMode.PAGED_MANGA;
        case types_1.Region.Korea:
            return daisuke_1.ReadingMode.WEBTOON;
        case types_1.Region.West:
            return daisuke_1.ReadingMode.PAGED_COMIC;
        default:
            return daisuke_1.ReadingMode.PAGED_MANGA;
    }
};
exports.readingModeByRegion = readingModeByRegion;
// Parse chapter title to extract volume and chapter numbers
const parseChapterTitle = (title) => {
    if (title === "全一卷") {
        return {
            volume: 1,
            chapter: 0,
            title,
        };
    }
    if (title === "全一話" || title === "全一话") {
        return {
            chapter: 1,
            title,
        };
    }
    const regex = /^(单行本：)?(第?(?<volume>[\d零一二三四五六七八九十百千]+(\.\d)?)[卷部季]完?)?((第|连载|CH)?(?<chapter>[\d零一二三四五六七八九十百千]+([-.]\d+)?)[話话回]?(-?[(（]?(?<part>([前中后上下]|\d+))[)）]?篇?)?(试看)?)?(\s.*|$)/;
    const match = regex.exec(title);
    if (!match || !match.groups) {
        return {
            chapter: 0,
            title,
        };
    }
    const getNumber = (str) => {
        if (!str)
            return;
        const chineseToArabic = {
            零: 0,
            一: 1,
            二: 2,
            三: 3,
            四: 4,
            五: 5,
            六: 6,
            七: 7,
            八: 8,
            九: 9,
            十: 10,
            百: 100,
            千: 1000,
        };
        const numericValue = parseFloat(str);
        if (!isNaN(numericValue)) {
            return numericValue;
        }
        let result = 0;
        let temp = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            const value = chineseToArabic[char];
            if (value >= 10) {
                result += (temp === 0 ? 1 : temp) * value;
                temp = 0;
            }
            else if (value !== undefined) {
                temp = value;
            }
        }
        return result + temp;
    };
    const volume = getNumber(match.groups.volume);
    const part = match.groups.part
        ? match.groups.part === "前" || match.groups.part === "上"
            ? "0"
            : match.groups.part === "中"
                ? "25"
                : match.groups.part === "后" || match.groups.part === "下"
                    ? "5"
                    : match.groups.part
        : "0";
    let chapter = getNumber(match.groups.chapter);
    if (chapter !== undefined && part) {
        const chapterStr = `${chapter}${chapter % 1 === 0 ? "." : ""}${part}`;
        chapter = parseFloat(chapterStr);
    }
    return {
        volume,
        chapter: chapter ?? 0,
        title,
    };
};
exports.parseChapterTitle = parseChapterTitle;
// Get timestamp from UUID
// 43acc6f8-5d5d-11ee-9412-d3d228a76de6
const getTimestampFromUuid = (uuid) => {
    try {
        // 验证UUID格式
        if (!uuid.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i)) {
            throw new Error("Invalid UUID format");
        }
        // 检查是否是版本1的UUID
        const version = uuid.charAt(14);
        if (version !== "1") {
            throw new Error("Not a version 1 UUID");
        }
        // 从UUID v1中提取时间戳部分
        // 时间低位（time_low）
        const timeLow = parseInt(uuid.substring(0, 8), 16);
        // 时间中位（time_mid）
        const timeMid = parseInt(uuid.substring(9, 13), 16);
        // 时间高位和版本（time_hi_and_version）- 需要去掉版本信息
        const timeHiAndVersion = parseInt(uuid.substring(15, 18), 16);
        // 组合时间戳（以100纳秒为单位）
        // 格式：time_low + time_mid * 2^32 + (time_hi_and_version & 0x0FFF) * 2^48
        const timestamp = timeLow + timeMid * Math.pow(2, 32) + timeHiAndVersion * Math.pow(2, 48);
        // UUID v1的时间戳是自1582-10-15 00:00:00以来的100纳秒间隔数
        // 转换为Unix时间戳（毫秒）
        const gregorianEpochInUnixTime = -12219292800000; // 1582-10-15 00:00:00 UTC in Unix time
        const unixTimestamp = gregorianEpochInUnixTime + timestamp / 10000;
        return unixTimestamp;
    }
    catch (error) {
        if (error instanceof Error) {
            console.error("Error extracting timestamp from UUID:", error.message);
            throw new Error(error.message);
        }
        else {
            console.error("Unknown error extracting timestamp from UUID");
            throw new Error("Failed to extract timestamp from UUID");
        }
    }
};
exports.getTimestampFromUuid = getTimestampFromUuid;
// Convert chapter groups to chapters array
const chapterGroupsToChapters = (groups, mangaId) => {
    const allChapters = [];
    Object.values(groups).forEach((group) => {
        const groupName = group.name;
        const titlePrefix = groupName === "默認" ? "" : `${groupName}：`;
        group.chapters.forEach((chapter) => {
            const chapterId = chapter.id;
            const title = `${titlePrefix}${chapter.name}`;
            try {
                const timestamp = (0, exports.getTimestampFromUuid)(chapterId);
                allChapters.push({
                    chapterId,
                    title,
                    timestamp,
                    groupName: groupName !== "默認" ? groupName : undefined,
                });
            }
            catch (error) {
                console.error(`Error processing chapter ${chapterId}:`, error);
            }
        });
    });
    allChapters.sort((a, b) => b.timestamp - a.timestamp);
    return allChapters.map((chapterInfo, index) => {
        const part = (0, exports.parseChapterTitle)(chapterInfo.title);
        return {
            id: chapterInfo.chapterId,
            chapterId: chapterInfo.chapterId,
            title: part.title,
            number: part.chapter,
            volume: part.volume,
            date: new Date(chapterInfo.timestamp * 1000),
            index,
            language: "zh",
            ...(chapterInfo.groupName && {
                providers: [{ id: chapterInfo.groupName, name: chapterInfo.groupName }],
            }),
            contentId: mangaId,
            url: `${constants_1.BASE_URL}/comic/${mangaId}/chapter/${chapterInfo.chapterId}`,
        };
    });
};
exports.chapterGroupsToChapters = chapterGroupsToChapters;
// Create network request with appropriate headers
const createNetworkRequest = (url) => {
    return {
        url,
        headers: constants_1.API_HEADERS,
    };
};
exports.createNetworkRequest = createNetworkRequest;
// API URL generators
const generateExploreUrl = (theme, top, ordering, page) => {
    return `${constants_1.API_URL}/comics?theme=${theme}&top=${top}&ordering=${ordering}&limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateExploreUrl = generateExploreUrl;
const generateSearchUrl = (query, page) => {
    return `${constants_1.API_URL}/search/comic?q=${encodeURIComponent(query)}&&limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateSearchUrl = generateSearchUrl;
const generateRankUrl = (dateType, page) => {
    return `${constants_1.API_URL}/ranks?date_type=${dateType}&limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateRankUrl = generateRankUrl;
const generateRecsUrl = (page) => {
    return `${constants_1.API_URL}/recs?pos=3200102&limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateRecsUrl = generateRecsUrl;
const generateNewestUrl = (page) => {
    return `${constants_1.API_URL}/update/newest?limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateNewestUrl = generateNewestUrl;
const generateMangaDetailsUrl = (id) => {
    return `${constants_1.API_URL}/comic2/${id}`;
};
exports.generateMangaDetailsUrl = generateMangaDetailsUrl;
const generateChapterListUrl = (id) => {
    return `${constants_1.BASE_URL}/comicdetail/${id}/chapters`;
};
exports.generateChapterListUrl = generateChapterListUrl;
const generatePageListUrl = (mangaId, chapterId) => {
    return `${constants_1.API_URL}/comic/${mangaId}/chapter/${chapterId}`;
};
exports.generatePageListUrl = generatePageListUrl;
// Check if the API response has more pages
const hasMorePages = (data) => {
    const total = data.total || 0;
    const offset = data.offset || 0;
    const limit = data.limit || constants_1.LIMIT;
    return offset + limit < total;
};
exports.hasMorePages = hasMorePages;

},{"./constants":1,"./types":3,"@suwatte/daisuke":5,"crypto-js":undefined}],5:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./runners"), exports);
__exportStar(require("./types"), exports);

},{"./runners":29,"./types":59}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],7:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],8:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],9:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],10:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],11:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],12:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],13:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],14:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],15:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ContentEvent"), exports);
__exportStar(require("./ChapterEvent"), exports);
__exportStar(require("./ProgressSync"), exports);
__exportStar(require("./LibrarySync"), exports);
__exportStar(require("./StreamContextProvider"), exports);
__exportStar(require("./ContextMenuHandler"), exports);
__exportStar(require("./GroupedUpdateProvider"), exports);
__exportStar(require("./ImageRedrawHandler"), exports);

},{"./ChapterEvent":7,"./ContentEvent":8,"./ContextMenuHandler":9,"./GroupedUpdateProvider":10,"./ImageRedrawHandler":11,"./LibrarySync":12,"./ProgressSync":13,"./StreamContextProvider":14}],16:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./handlers"), exports);
__exportStar(require("./ContentSource"), exports);

},{"./ContentSource":6,"./handlers":15}],17:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],18:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],19:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ContentTracker"), exports);
__exportStar(require("./AdvancedTracker"), exports);

},{"./AdvancedTracker":17,"./ContentTracker":18}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicAuthenticationUIIdentifier = void 0;
var BasicAuthenticationUIIdentifier;
(function (BasicAuthenticationUIIdentifier) {
    BasicAuthenticationUIIdentifier[BasicAuthenticationUIIdentifier["EMAIL"] = 0] = "EMAIL";
    BasicAuthenticationUIIdentifier[BasicAuthenticationUIIdentifier["USERNAME"] = 1] = "USERNAME";
})(BasicAuthenticationUIIdentifier || (exports.BasicAuthenticationUIIdentifier = BasicAuthenticationUIIdentifier = {}));

},{}],21:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],22:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],23:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],24:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],25:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],26:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],27:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Authentication"), exports);
__exportStar(require("./Preferences"), exports);
__exportStar(require("./ImageRequest"), exports);
__exportStar(require("./DirectoryHandler"), exports);
__exportStar(require("./PageProvider"), exports);
__exportStar(require("./Setup"), exports);
__exportStar(require("./PageResolver"), exports);

},{"./Authentication":20,"./DirectoryHandler":21,"./ImageRequest":22,"./PageProvider":23,"./PageResolver":24,"./Preferences":25,"./Setup":26}],28:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunnerEnvironment = void 0;
__exportStar(require("./extensions"), exports);
var RunnerEnvironment;
(function (RunnerEnvironment) {
    RunnerEnvironment[RunnerEnvironment["SOURCE"] = 0] = "SOURCE";
    RunnerEnvironment[RunnerEnvironment["TRACKER"] = 1] = "TRACKER";
})(RunnerEnvironment || (exports.RunnerEnvironment = RunnerEnvironment = {}));

},{"./extensions":27}],29:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ContentSource"), exports);
__exportStar(require("./Runner"), exports);
__exportStar(require("./ContentTracker"), exports);

},{"./ContentSource":16,"./ContentTracker":19,"./Runner":28}],30:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],31:[function(require,module,exports){
"use strict";
// Picker
Object.defineProperty(exports, "__esModule", { value: true });

},{}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIStepper = exports.UIButton = exports.UIDatePicker = exports.UITextField = exports.UIToggle = exports.UIMultiPicker = exports.UIPicker = void 0;
const UIElements_1 = require("./UIElements");
const UIPicker = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.SELECT }));
exports.UIPicker = UIPicker;
const UIMultiPicker = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.MULTISELECT }));
exports.UIMultiPicker = UIMultiPicker;
const UIToggle = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.TOGGLE }));
exports.UIToggle = UIToggle;
const UITextField = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.TEXTFIELD }));
exports.UITextField = UITextField;
const UIDatePicker = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.DATEPICKER }));
exports.UIDatePicker = UIDatePicker;
const UIButton = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.BUTTON }));
exports.UIButton = UIButton;
const UIStepper = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.STEPPER }));
exports.UIStepper = UIStepper;

},{"./UIElements":33}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIComponentType = void 0;
var UIComponentType;
(function (UIComponentType) {
    UIComponentType[UIComponentType["SELECT"] = 0] = "SELECT";
    UIComponentType[UIComponentType["MULTISELECT"] = 1] = "MULTISELECT";
    UIComponentType[UIComponentType["STEPPER"] = 2] = "STEPPER";
    UIComponentType[UIComponentType["TOGGLE"] = 3] = "TOGGLE";
    UIComponentType[UIComponentType["TEXTFIELD"] = 4] = "TEXTFIELD";
    UIComponentType[UIComponentType["BUTTON"] = 5] = "BUTTON";
    UIComponentType[UIComponentType["DATEPICKER"] = 6] = "DATEPICKER";
})(UIComponentType || (exports.UIComponentType = UIComponentType = {}));

},{}],34:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Form"), exports);
__exportStar(require("./UIElements"), exports);
__exportStar(require("./UIDefinitions"), exports);
__exportStar(require("./UIElementBuilders"), exports);

},{"./Form":30,"./UIDefinitions":31,"./UIElementBuilders":32,"./UIElements":33}],35:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefinedLanguages = void 0;
var DefinedLanguages;
(function (DefinedLanguages) {
    DefinedLanguages["UNIVERSAL"] = "UNIVERSAL";
    DefinedLanguages["ENGLISH"] = "en_US";
    DefinedLanguages["KOREAN"] = "ko_KR";
    DefinedLanguages["JAPANESE"] = "ja_JP";
    DefinedLanguages["FRENCH"] = "fr_FR";
    DefinedLanguages["CHINESE"] = "zh-CN";
    DefinedLanguages["SPANISH"] = "es_ES";
    DefinedLanguages["PORTUGUESE"] = "pt_BR";
})(DefinedLanguages || (exports.DefinedLanguages = DefinedLanguages = {}));

},{}],37:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],38:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],39:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],40:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],41:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],42:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentType = exports.ReadingFlag = exports.ReadingMode = exports.PublicationStatus = void 0;
// Enums
var PublicationStatus;
(function (PublicationStatus) {
    PublicationStatus[PublicationStatus["ONGOING"] = 1] = "ONGOING";
    PublicationStatus[PublicationStatus["COMPLETED"] = 2] = "COMPLETED";
    PublicationStatus[PublicationStatus["CANCELLED"] = 3] = "CANCELLED";
    PublicationStatus[PublicationStatus["HIATUS"] = 4] = "HIATUS";
})(PublicationStatus || (exports.PublicationStatus = PublicationStatus = {}));
/**
 * The method in which the content can be read
 */
var ReadingMode;
(function (ReadingMode) {
    ReadingMode[ReadingMode["PAGED_MANGA"] = 0] = "PAGED_MANGA";
    ReadingMode[ReadingMode["PAGED_COMIC"] = 1] = "PAGED_COMIC";
    ReadingMode[ReadingMode["PAGED_VERTICAL"] = 2] = "PAGED_VERTICAL";
    ReadingMode[ReadingMode["WEBTOON"] = 3] = "WEBTOON";
})(ReadingMode || (exports.ReadingMode = ReadingMode = {}));
var ReadingFlag;
(function (ReadingFlag) {
    ReadingFlag[ReadingFlag["READING"] = 0] = "READING";
    ReadingFlag[ReadingFlag["PLANNED"] = 1] = "PLANNED";
    ReadingFlag[ReadingFlag["COMPLETED"] = 2] = "COMPLETED";
    ReadingFlag[ReadingFlag["DROPPED"] = 3] = "DROPPED";
    ReadingFlag[ReadingFlag["REREADING"] = 4] = "REREADING";
    ReadingFlag[ReadingFlag["PAUSED"] = 5] = "PAUSED";
    ReadingFlag[ReadingFlag["UNKNOWN"] = 6] = "UNKNOWN";
})(ReadingFlag || (exports.ReadingFlag = ReadingFlag = {}));
var ContentType;
(function (ContentType) {
    ContentType[ContentType["MANGA"] = 0] = "MANGA";
    ContentType[ContentType["MANHUA"] = 1] = "MANHUA";
    ContentType[ContentType["MANHWA"] = 2] = "MANHWA";
    ContentType[ContentType["COMIC"] = 3] = "COMIC";
    ContentType[ContentType["NOVEL"] = 4] = "NOVEL";
})(ContentType || (exports.ContentType = ContentType = {}));

},{}],44:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],45:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],46:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderLinkType = void 0;
var ProviderLinkType;
(function (ProviderLinkType) {
    ProviderLinkType[ProviderLinkType["WEBSITE"] = 0] = "WEBSITE";
    ProviderLinkType[ProviderLinkType["TWITTER"] = 1] = "TWITTER";
    ProviderLinkType[ProviderLinkType["DISCORD"] = 2] = "DISCORD";
    ProviderLinkType[ProviderLinkType["PATREON"] = 3] = "PATREON";
})(ProviderLinkType || (exports.ProviderLinkType = ProviderLinkType = {}));

},{}],48:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],49:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Content"), exports);
__exportStar(require("./Highlight"), exports);
__exportStar(require("./Chapter"), exports);
__exportStar(require("./ChapterData"), exports);
__exportStar(require("./Property"), exports);
__exportStar(require("./Collection"), exports);
__exportStar(require("./Provider"), exports);
__exportStar(require("./Enums"), exports);
__exportStar(require("./ReaderContext"), exports);
__exportStar(require("./ContextMenu"), exports);
__exportStar(require("./DeepLinkContext"), exports);
__exportStar(require("./BooleanState"), exports);
__exportStar(require("./ContentProgressState"), exports);
__exportStar(require("./GroupedUpdatesResponse"), exports);

},{"./BooleanState":35,"./Chapter":36,"./ChapterData":37,"./Collection":38,"./Content":39,"./ContentProgressState":40,"./ContextMenu":41,"./DeepLinkContext":42,"./Enums":43,"./GroupedUpdatesResponse":44,"./Highlight":45,"./Property":46,"./Provider":47,"./ReaderContext":48}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthMethod = void 0;
var AuthMethod;
(function (AuthMethod) {
    AuthMethod[AuthMethod["USERNAME_PW"] = 0] = "USERNAME_PW";
    AuthMethod[AuthMethod["EMAIL_PW"] = 1] = "EMAIL_PW";
    AuthMethod[AuthMethod["WEB"] = 2] = "WEB";
    AuthMethod[AuthMethod["OAUTH"] = 3] = "OAUTH";
})(AuthMethod || (exports.AuthMethod = AuthMethod = {}));

},{}],51:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],52:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CatalogRating = void 0;
var CatalogRating;
(function (CatalogRating) {
    /**
     * Catalog does not contain ANY SUGGESTIVE OR NSFW content
     */
    CatalogRating[CatalogRating["SAFE"] = 0] = "SAFE";
    /**
     * Catalog may contain SUGGESTIVE OR NSFW content,
     * runners must hide NSFW content by default,
     * users will be required to verify they are of age to view NSFW content
     */
    CatalogRating[CatalogRating["MIXED"] = 1] = "MIXED";
    /**
     * Catalog contains MAINLY SUGGESTIVE OR NSFW content,
     * users will be required to verify they are of age to view NSFW content
     */
    CatalogRating[CatalogRating["NSFW"] = 2] = "NSFW";
})(CatalogRating || (exports.CatalogRating = CatalogRating = {}));

},{}],54:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Authentication"), exports);
__exportStar(require("./RunnerInfo"), exports);
__exportStar(require("./PagedResult"), exports);
__exportStar(require("./ContextProvider"), exports);

},{"./Authentication":50,"./ContextProvider":51,"./PagedResult":52,"./RunnerInfo":53}],55:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterType = void 0;
var FilterType;
(function (FilterType) {
    /**
     * This Represents the filter as a toggle switch, the value returned in the directory request will be a `boolean`
     */
    FilterType[FilterType["TOGGLE"] = 0] = "TOGGLE";
    /**
     * This represents the filter as a picker, the value returned will be the `key` of the selected option as a `string`
     */
    FilterType[FilterType["SELECT"] = 1] = "SELECT";
    /**
     * This Represents the filter as a multi-picker, the value returned will the the keys of the selected options as an array of strings
     */
    FilterType[FilterType["MULTISELECT"] = 2] = "MULTISELECT";
    /**
     * This Represents the filter as a multi-picker,the value returned will be of type {@link ExcludableMultiSelectProp}
     */
    FilterType[FilterType["EXCLUDABLE_MULTISELECT"] = 3] = "EXCLUDABLE_MULTISELECT";
    /**
     * This will represent the filter as a textfield, the value returned will be a string
     */
    FilterType[FilterType["TEXT"] = 4] = "TEXT";
    /**
     * This is a basic filter that will only display the title or subtitle, it will not return any value in the populated `DirectoryRequest`
     */
    FilterType[FilterType["INFO"] = 5] = "INFO";
})(FilterType || (exports.FilterType = FilterType = {}));

},{}],57:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],58:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./DirectoryConfig"), exports);
__exportStar(require("./DirectoryRequest"), exports);
__exportStar(require("./DirectoryFilter"), exports);

},{"./DirectoryConfig":55,"./DirectoryFilter":56,"./DirectoryRequest":57}],59:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generate = void 0;
__exportStar(require("./core"), exports);
__exportStar(require("./content"), exports);
__exportStar(require("./networking"), exports);
__exportStar(require("./UI"), exports);
__exportStar(require("./tracker"), exports);
__exportStar(require("./directory"), exports);
__exportStar(require("./page"), exports);
const Generate = (v) => v;
exports.Generate = Generate;

},{"./UI":34,"./content":49,"./core":54,"./directory":58,"./networking":66,"./page":67,"./tracker":68}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkClientBuilder = void 0;
/**
 * NetworkClientBuilder is a builder class used for creating and configuring instances of NetworkClient.
 * The builder allows you to configure various aspects of the NetworkClient, such as rate limits,
 * request/response transformers (interceptors), headers, cookies, timeout, status validator, and more.
 */
class NetworkClientBuilder {
    constructor() {
        // Array of functions that transform requests
        this.requestTransformers = [];
        // Array of functions that transform responses
        this.responseTransformers = [];
        // Object representing HTTP headers, where each key-value pair represents a header
        this.headers = {};
        // Array of cookies
        this.cookies = [];
    }
    /**
     * Sets the rate limit for the NetworkClient.
     *
     * @param requests - The maximum number of requests to make per interval.
     * @param interval - The length of the rate limiting interval in seconds.
     * @returns The builder, to allow for method chaining.
     */
    setRateLimit(requests, interval) {
        this.requestsPerSecond = requests / interval;
        return this;
    }
    /**
     * Adds a request interceptor to the NetworkClient.
     *
     * @param transformer - The interceptor to add. This should be a function that takes a request and modifies it in some way.
     * @returns The builder, to allow for method chaining.
     */
    addRequestInterceptor(transformer) {
        this.requestTransformers.push(transformer);
        return this;
    }
    /**
     * Adds a response interceptor to the NetworkClient.
     *
     * @param transformer - The interceptor to add. This should be a function that takes a response and modifies it in some way.
     * @returns The builder, to allow for method chaining.
     */
    addResponseInterceptor(transformer) {
        this.responseTransformers.push(transformer);
        return this;
    }
    /**
     * Sets the authorization token for the NetworkClient.
     *
     * @param token - The token to be included in the Authorization header of every request.
     * @returns The builder, to allow for method chaining.
     */
    setAuthorizationToken(token) {
        return this.addHeader("Authorization", token);
    }
    /**
     * Sets the status validator for the NetworkClient.
     *
     * @param validator - A function that takes a status code and returns true if it is considered successful.
     * @returns The builder, to allow for method chaining.
     */
    setStatusValidator(validator) {
        this.statusValidator = validator;
        return this;
    }
    /**
     * Sets the timeout for requests made by the NetworkClient.
     *
     * @param timeout - The maximum time to wait for a request to complete, in milliseconds.
     * @returns The builder, to allow for method chaining.
     */
    setTimeout(timeout) {
        this.timeout = timeout;
        return this;
    }
    /**
     * Sets the maximum number of retries for this request by the NetworkClient.
     *
     * @param retries - The maximum number of retries for this request
     * @returns The builder, to allow for method chaining.
     */
    setMaxRetries(retries) {
        this.maxRetries = retries;
        return this;
    }
    /**
     * Sets a header for the NetworkClient.
     *
     * @param key - The name of the header
     * @param value - The value of the header
     * @returns The builder, to allow for method chaining.
     */
    addHeader(key, value) {
        this.headers[key] = value;
        return this;
    }
    /**
     * Sets a cookie for the NetworkClient.
     *
     * @param cookie - The cookie to be included in every request.
     * @returns The builder, to allow for method chaining.
     */
    addCookie(cookie) {
        this.cookies.push(cookie);
        return this;
    }
    /**
     * Builds a NetworkClient using the parameters set on the builder.
     *
     * @returns A NetworkClient with the configured parameters.
     */
    build() {
        return new NetworkClient(this);
    }
}
exports.NetworkClientBuilder = NetworkClientBuilder;

},{}],61:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],62:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],63:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.name = void 0;
const name = (base, known) => __awaiter(void 0, void 0, void 0, function* () {
    return Object.assign(Object.assign({}, base), known);
});
exports.name = name;

},{}],64:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],65:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"dup":6}],66:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Builder"), exports);
__exportStar(require("./Client"), exports);
__exportStar(require("./Request"), exports);
__exportStar(require("./Response"), exports);
__exportStar(require("./Transformer"), exports);
__exportStar(require("./Error"), exports);

},{"./Builder":60,"./Client":61,"./Error":62,"./Request":63,"./Response":64,"./Transformer":65}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SectionStyle = void 0;
var SectionStyle;
(function (SectionStyle) {
    SectionStyle[SectionStyle["DEFAULT"] = 0] = "DEFAULT";
    SectionStyle[SectionStyle["INFO"] = 1] = "INFO";
    SectionStyle[SectionStyle["GALLERY"] = 2] = "GALLERY";
    SectionStyle[SectionStyle["NAVIGATION_LIST"] = 3] = "NAVIGATION_LIST";
    SectionStyle[SectionStyle["ITEM_LIST"] = 4] = "ITEM_LIST";
    SectionStyle[SectionStyle["PADDED_LIST"] = 5] = "PADDED_LIST";
    SectionStyle[SectionStyle["TAG"] = 6] = "TAG";
    SectionStyle[SectionStyle["STANDARD_GRID"] = 7] = "STANDARD_GRID";
})(SectionStyle || (exports.SectionStyle = SectionStyle = {}));

},{}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackStatus = void 0;
var TrackStatus;
(function (TrackStatus) {
    TrackStatus["READING"] = "READING";
    TrackStatus["PLANNING"] = "PLANNING";
    TrackStatus["COMPLETED"] = "COMPLETED";
    TrackStatus["PAUSED"] = "PAUSED";
    TrackStatus["DROPPED"] = "DROPPED";
    TrackStatus["REREADING"] = "REREADING";
})(TrackStatus || (exports.TrackStatus = TrackStatus = {}));

},{}]},{},[2])(2)
});
