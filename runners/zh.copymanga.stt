(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.STTPackage = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DOMAINS = exports.LISTING_TYPES = exports.LIMIT = exports.DECRYPT_KEY = exports.EXPLORE_COLLECTIONS = exports.getProperties = exports.THEME_OPTIONS = exports.REGION_OPTIONS = exports.STATUS_OPTIONS = exports.SORT_OPTIONS = void 0;
const daisuke_1 = require("@suwatte/daisuke");
exports.SORT_OPTIONS = [
    { title: "更新時間", id: "datetime_updated" },
    { title: "熱門", id: "popular" },
];
exports.STATUS_OPTIONS = [
    { title: "全部", id: "-1" },
    { title: "連載中", id: "0" },
    { title: "已完結", id: "1" },
    { title: "短篇", id: "2" },
];
exports.REGION_OPTIONS = [
    { title: "全部", id: "-1" },
    { title: "日漫", id: "0" },
    { title: "韓漫", id: "1" },
    { title: "美漫", id: "2" },
];
exports.THEME_OPTIONS = [
    { title: "全部", id: "" },
    { title: "愛情", id: "aiqing" },
    { title: "歡樂向", id: "huanlexiang" },
    { title: "冒險", id: "maoxian" },
    { title: "奇幻", id: "qihuan" },
    { title: "百合", id: "baihe" },
    { title: "校園", id: "xiaoyuan" },
    { title: "科幻", id: "kehuan" },
    { title: "東方", id: "dongfang" },
    { title: "耽美", id: "danmei" },
    { title: "生活", id: "shenghuo" },
    { title: "格鬥", id: "gedou" },
    { title: "輕小說", id: "qingxiaoshuo" },
    { title: "懸疑", id: "xuanyi" },
    { title: "其他", id: "qita" },
    { title: "神鬼", id: "shengui" },
    { title: "職場", id: "zhichang" },
    { title: "TL", id: "teenslove" },
    { title: "萌系", id: "mengxi" },
    { title: "治癒", id: "zhiyu" },
    { title: "長條", id: "changtiao" },
    { title: "四格", id: "sige" },
    { title: "節操", id: "jiecao" },
    { title: "艦娘", id: "jianniang" },
    { title: "競技", id: "jingji" },
    { title: "搞笑", id: "gaoxiao" },
    { title: "偽娘", id: "weiniang" },
    { title: "熱血", id: "rexue" },
    { title: "勵志", id: "lizhi" },
    { title: "性轉換", id: "xingzhuanhuan" },
    { title: "彩色", id: "COLOR" },
    { title: "後宮", id: "hougong" },
    { title: "美食", id: "meishi" },
    { title: "偵探", id: "zhentan" },
    { title: "AA", id: "aa" },
    { title: "音樂舞蹈", id: "yinyuewudao" },
    { title: "魔幻", id: "mohuan" },
    { title: "戰爭", id: "zhanzheng" },
    { title: "歷史", id: "lishi" },
    { title: "異世界", id: "yishijie" },
    { title: "驚悚", id: "jingsong" },
    { title: "機戰", id: "jizhan" },
    { title: "都市", id: "dushi" },
    { title: "穿越", id: "chuanyue" },
    { title: "恐怖", id: "kongbu" },
    { title: "C100", id: "comiket100" },
    { title: "重生", id: "chongsheng" },
    { title: "C99", id: "comiket99" },
    { title: "C101", id: "comiket101" },
    { title: "C97", id: "comiket97" },
    { title: "C96", id: "comiket96" },
    { title: "生存", id: "shengcun" },
    { title: "宅系", id: "zhaixi" },
    { title: "武俠", id: "wuxia" },
    { title: "C98", id: "C98" },
    { title: "C95", id: "comiket95" },
    { title: "FATE", id: "fate" },
    { title: "轉生", id: "zhuansheng" },
    { title: "無修正", id: "Uncensored" },
    { title: "仙俠", id: "xianxia" },
    { title: "LoveLive", id: "loveLive" },
];
const getProperties = () => {
    const properties = [];
    // Theme
    properties.push({
        id: "theme",
        title: "題材",
        tags: exports.THEME_OPTIONS,
    });
    // Status
    properties.push({
        id: "status",
        title: "狀態",
        tags: exports.STATUS_OPTIONS,
    });
    // Region
    properties.push({
        id: "region",
        title: "地區",
        tags: exports.REGION_OPTIONS,
    });
    return properties;
};
exports.getProperties = getProperties;
exports.EXPLORE_COLLECTIONS = [
    {
        id: "latest",
        title: "最新更新",
        style: daisuke_1.SectionStyle.PADDED_LIST,
    },
    {
        id: "popular",
        title: "熱門漫畫",
        style: daisuke_1.SectionStyle.INFO,
    },
];
// AES Decryption Key
exports.DECRYPT_KEY = "xxxmanga.woo.key";
// Default limit for manga per page
exports.LIMIT = 30;
// Listing types
exports.LISTING_TYPES = {
    DAY_RANK: "day",
    WEEK_RANK: "week",
    MONTH_RANK: "month",
    TOTAL_RANK: "total",
    RECS: "recs",
    NEWEST: "newest",
};
exports.DOMAINS = {
    China: "2025copy.com",
    Global: "mangacopy.com",
};

},{"@suwatte/daisuke":6}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Target = exports.info = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const store_1 = require("./store");
exports.info = {
    id: "zh.copymanga",
    name: "拷贝漫画",
    version: 1.2,
    website: "https://www.mangacopy.com/",
    supportedLanguages: ["zh"],
    thumbnail: "copymanga.png",
    minSupportedAppVersion: "5.0",
    rating: daisuke_1.CatalogRating.MIXED,
};
class Target {
    client = new NetworkClient();
    info = exports.info;
    // Get manga details
    async getContent(contentId) {
        const baseUrl = await (0, utils_1.getBaseUrl)();
        const url = await (0, utils_1.generateMangaDetailsUrl)(contentId);
        console.info(`GET: ${url}`);
        const headers = await (0, utils_1.getRequestHeaders)();
        const response = await this.client.get(url, { headers });
        // Parse HTML to extract manga details
        const titleMatch = response.data.match(/<h6[^>]*>([^<]+)<\/h6>/);
        const title = titleMatch ? titleMatch[1].trim() : "";
        const coverMatch = response.data.match(/img[^>]*data-src="([^"]+)"/);
        const cover = coverMatch ? coverMatch[1].replace(".328x422.jpg", "") : "";
        // Extract authors from span.comicParticulars-right-txt > a
        const authorsMatch = response.data.match(/<span class="comicParticulars-right-txt">([\s\S]*?)<\/span>/);
        const creators = [];
        if (authorsMatch) {
            const authorLinks = authorsMatch[1].match(/<a[^>]*>([^<]+)<\/a>/g) || [];
            authorLinks.forEach((link) => {
                const nameMatch = link.match(/>([^<]+)</);
                if (nameMatch)
                    creators.push(nameMatch[1].trim());
            });
        }
        // Extract summary
        const summaryMatch = response.data.match(/<p class="intro"[^>]*>([^<]*)<\/p>/);
        const summary = summaryMatch ? summaryMatch[1].trim() : "";
        // Extract tags
        const tagsMatch = response.data.match(/<span class="comicParticulars-tag">([\s\S]*?)<\/span>/);
        const themes = [];
        if (tagsMatch) {
            const tagLinks = tagsMatch[1].match(/<a[^>]*>([^<]+)<\/a>/g) || [];
            tagLinks.forEach((link) => {
                const tagMatch = link.match(/>([^<]+)</);
                if (tagMatch) {
                    const tag = tagMatch[1].trim().replace(/^#/, "");
                    themes.push({ id: tag, title: tag });
                }
            });
        }
        // Extract status
        const statusMatch = response.data.match(/狀態：<\/li>[\s\S]*?<span class="comicParticulars-right-txt"[^>]*>([^<]+)<\/span>/);
        let status = daisuke_1.PublicationStatus.ONGOING;
        if (statusMatch) {
            const statusText = statusMatch[1].trim();
            if (statusText === "已完結" || statusText === "短篇") {
                status = daisuke_1.PublicationStatus.COMPLETED;
            }
        }
        return {
            title,
            cover,
            creators,
            summary,
            status,
            webUrl: `${baseUrl}/comic/${contentId}`,
            properties: themes.length > 0
                ? [
                    {
                        id: "theme",
                        title: "題材",
                        tags: themes,
                    },
                ]
                : [],
        };
    }
    // Get chapter list for a manga
    async getChapters(contentId) {
        // First, get the HTML manga detail page to extract the decryption key
        const baseUrl = await (0, utils_1.getBaseUrl)();
        const mangaPageUrl = `${baseUrl}/comic/${contentId}`;
        const detailHeaders = await (0, utils_1.getRequestHeaders)();
        const mangaPageResponse = await this.client.get(mangaPageUrl, {
            headers: detailHeaders,
        });
        // Extract the key from script tags in the HTML page
        // The key is in a script tag like: var key = 'some-key'
        const keyMatch = mangaPageResponse.data.match(/var\s+\w+\s*=\s*'([^']+)'/);
        if (!keyMatch || !keyMatch[1]) {
            throw new Error("Failed to extract decryption key from manga page");
        }
        const decryptionKey = keyMatch[1];
        // Now get the chapter list
        const url = await (0, utils_1.generateChapterListUrl)(contentId);
        console.info(`GET: ${url}`);
        const headers = await (0, utils_1.getRequestHeaders)({ includesDnts: true });
        const response = await this.client.get(url, { headers });
        const resultsMatch = response.data.match(/"results":"([^"]+)"/);
        if (!resultsMatch || !resultsMatch[1]) {
            return [];
        }
        const encryptedResults = resultsMatch[1];
        const decryptedResults = (0, utils_1.decryptString)(encryptedResults, decryptionKey);
        try {
            const chapterListData = JSON.parse(decryptedResults);
            return (0, utils_1.chapterGroupsToChapters)(chapterListData.groups, chapterListData.build.path_word);
        }
        catch (error) {
            console.error("Error parsing chapter list:", error);
            return [];
        }
    }
    // Get page list for a chapter
    async getChapterData(contentId, chapterId) {
        const url = await (0, utils_1.generatePageListUrl)(contentId, chapterId);
        const headers = await (0, utils_1.getRequestHeaders)();
        console.info(`GET: ${url}`);
        const response = await this.client.get(url, { headers });
        // Extract the decryption key from script tag (same as in getChapters)
        const keyMatch = response.data.match(/var\s+\w+\s*=\s*'([^']+)'/);
        if (!keyMatch || !keyMatch[1]) {
            throw new Error("Failed to extract decryption key from chapter page");
        }
        const key = keyMatch[1];
        // Extract encrypted contentKey from script
        const contentKeyMatch = response.data.match(/var contentKey = '([^']+)'/);
        if (!contentKeyMatch || !contentKeyMatch[1]) {
            throw new Error("Failed to extract encrypted content key");
        }
        const encryptedContentKey = contentKeyMatch[1];
        const decryptedContent = (0, utils_1.decryptString)(encryptedContentKey, key);
        const pageList = JSON.parse(decryptedContent);
        const pages = pageList.map((page, index) => ({
            index,
            url: page.url,
        }));
        return { pages };
    }
    // Get tags
    async getTags() {
        return (0, constants_1.getProperties)();
    }
    // Get manga list based on filters and page
    async getDirectory(request) {
        const params = (0, utils_1.parseSearchRequest)(request);
        if (request.listId) {
            return this.getListing({ id: request.listId }, request.page || 1);
        }
        if (params.q) {
            return this.search(params.q, request.page || 1);
        }
        return this.browse(params);
    }
    // Search for manga
    async search(query, page) {
        const url = await (0, utils_1.generateSearchUrl)(query, page);
        const headers = await (0, utils_1.getRequestHeaders)();
        console.info(`GET: ${url}`);
        const response = await this.client.get(url, { headers });
        const data = JSON.parse(response.data);
        if (!data.results || !data.results.list) {
            return { results: [], isLastPage: true };
        }
        const mangaList = data.results.list;
        const hasMore = (0, utils_1.hasMorePages)(data.results);
        return (0, utils_1.mangaListToPageResult)(mangaList, hasMore);
    }
    // Browse manga with filters
    async browse(params) {
        const theme = params.theme || "";
        const top = params.region || "";
        const ordering = params.ordering || "-datetime_updated";
        const offset = params.offset || 0;
        const limit = params.limit || 50;
        const page = Math.floor(offset / limit) + 1;
        const url = await (0, utils_1.generateExploreUrl)(theme, top, ordering, page);
        const headers = await (0, utils_1.getRequestHeaders)();
        console.info(`GET: ${url}`);
        const response = await this.client.get(url, { headers });
        // Parse HTML to extract manga list from div.exemptComic-box[list] attribute
        const listMatch = response.data.match(/class="row exemptComic-box"[^>]*list="([^"]+)"/);
        if (!listMatch || !listMatch[1]) {
            return { results: [], isLastPage: true };
        }
        // Decode HTML entities and convert single quotes to double quotes
        const listJson = listMatch[1]
            .replace(/&#x27;/g, "'")
            .replace(/&#39;/g, "'")
            .replace(/'([^']+)':/g, '"$1":') // Convert keys
            .replace(/:\s*'([^']*)'/g, ': "$1"'); // Convert string values
        const mangaList = JSON.parse(listJson);
        // Check if there's a next page by looking at pagination
        const hasMore = !response.data.includes('li class="page-all-item active"');
        return (0, utils_1.mangaListToPageResult)(mangaList, hasMore);
    }
    // Get directory config
    async getDirectoryConfig() {
        return {
            filters: [
                {
                    id: "theme",
                    title: "題材",
                    type: daisuke_1.FilterType.SELECT,
                    options: (0, constants_1.getProperties)().find((p) => p.id === "theme")?.tags || [],
                },
                {
                    id: "status",
                    title: "狀態",
                    type: daisuke_1.FilterType.SELECT,
                    options: (0, constants_1.getProperties)().find((p) => p.id === "status")?.tags || [],
                },
                {
                    id: "region",
                    title: "地區",
                    type: daisuke_1.FilterType.SELECT,
                    options: (0, constants_1.getProperties)().find((p) => p.id === "region")?.tags || [],
                },
            ],
            sort: {
                options: constants_1.SORT_OPTIONS,
                default: {
                    id: "datetime_updated",
                    ascending: false,
                },
                canChangeOrder: true,
            },
            lists: [
                {
                    id: constants_1.LISTING_TYPES.DAY_RANK,
                    title: "日榜",
                },
                {
                    id: constants_1.LISTING_TYPES.WEEK_RANK,
                    title: "周榜",
                },
                {
                    id: constants_1.LISTING_TYPES.MONTH_RANK,
                    title: "月榜",
                },
                {
                    id: constants_1.LISTING_TYPES.TOTAL_RANK,
                    title: "總榜",
                },
                {
                    id: constants_1.LISTING_TYPES.RECS,
                    title: "推薦",
                },
                {
                    id: constants_1.LISTING_TYPES.NEWEST,
                    title: "最新",
                },
            ],
        };
    }
    // Get listing for a specific category
    async getListing(listing, page = 1) {
        let url;
        switch (listing.id) {
            case constants_1.LISTING_TYPES.DAY_RANK:
                url = await (0, utils_1.generateRankUrl)(constants_1.LISTING_TYPES.DAY_RANK, page);
                break;
            case constants_1.LISTING_TYPES.WEEK_RANK:
                url = await (0, utils_1.generateRankUrl)(constants_1.LISTING_TYPES.WEEK_RANK, page);
                break;
            case constants_1.LISTING_TYPES.MONTH_RANK:
                url = await (0, utils_1.generateRankUrl)(constants_1.LISTING_TYPES.MONTH_RANK, page);
                break;
            case constants_1.LISTING_TYPES.TOTAL_RANK:
                url = await (0, utils_1.generateRankUrl)(constants_1.LISTING_TYPES.TOTAL_RANK, page);
                break;
            case constants_1.LISTING_TYPES.RECS:
                url = await (0, utils_1.generateRecsUrl)(page);
                break;
            case constants_1.LISTING_TYPES.NEWEST:
                url = await (0, utils_1.generateNewestUrl)(page);
                break;
            default:
                return this.getDirectory({ page });
        }
        const headers = await (0, utils_1.getRequestHeaders)();
        console.info(`GET: ${url}`);
        const response = await this.client.get(url, { headers });
        const data = JSON.parse(response.data);
        if (!data.results || !data.results.list) {
            return { results: [], isLastPage: true };
        }
        const mangaList = data.results.list.map((manga) => ({
            ...manga.comic,
            status: 1,
        }));
        const hasMore = (0, utils_1.hasMorePages)(data.results);
        return (0, utils_1.mangaListToPageResult)(mangaList, hasMore);
    }
    // Handle image requests
    async willRequestImage(url) {
        const headers = await (0, utils_1.getRequestHeaders)();
        return {
            url,
            headers,
        };
    }
    async getPreferenceMenu() {
        return {
            sections: [
                {
                    header: "Core",
                    children: [
                        (0, daisuke_1.UIPicker)({
                            id: "domain",
                            title: "Domain",
                            value: (await store_1.ConfigStore.domain()) || constants_1.DOMAINS.China,
                            options: [
                                { id: constants_1.DOMAINS.China, title: `China(${constants_1.DOMAINS.China})` },
                                { id: constants_1.DOMAINS.Global, title: `Global(${constants_1.DOMAINS.Global})` },
                            ],
                            async didChange(value) {
                                await ObjectStore.set("domain", value);
                            },
                        }),
                    ],
                },
            ],
        };
    }
}
exports.Target = Target;

},{"./constants":1,"./store":3,"./utils":5,"@suwatte/daisuke":6}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigStore = void 0;
exports.ConfigStore = {
    domain: () => ObjectStore.string("domain"),
};

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Region = exports.Status = exports.SearchType = void 0;
var SearchType;
(function (SearchType) {
    SearchType["All"] = "";
    SearchType["Title"] = "name";
    SearchType["Author"] = "author";
    SearchType["Translator"] = "local";
})(SearchType = exports.SearchType || (exports.SearchType = {}));
var Status;
(function (Status) {
    Status[Status["All"] = -1] = "All";
    Status[Status["Ongoing"] = 0] = "Ongoing";
    Status[Status["Completed"] = 1] = "Completed";
    Status[Status["OneShot"] = 2] = "OneShot";
})(Status = exports.Status || (exports.Status = {}));
var Region;
(function (Region) {
    Region[Region["All"] = -1] = "All";
    Region[Region["Japan"] = 0] = "Japan";
    Region[Region["Korea"] = 1] = "Korea";
    Region[Region["West"] = 2] = "West";
})(Region = exports.Region || (exports.Region = {}));

},{}],5:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasMorePages = exports.generatePageListUrl = exports.generateChapterListUrl = exports.generateMangaDetailsUrl = exports.generateNewestUrl = exports.generateRecsUrl = exports.generateRankUrl = exports.generateSearchUrl = exports.getSearchApiEndpoint = exports.generateExploreUrl = exports.chapterGroupsToChapters = exports.getTimestampFromUuid = exports.parseChapterTitle = exports.readingModeByRegion = exports.regionToDisplay = exports.convertRegion = exports.convertStatus = exports.mangaListToPageResult = exports.mangaToHighlight = exports.parseSearchRequest = exports.decryptString = exports.getRequestHeaders = exports.getApiBaseUrl = exports.getBaseUrl = void 0;
const daisuke_1 = require("@suwatte/daisuke");
const types_1 = require("./types");
const constants_1 = require("./constants");
const crypto_js_1 = __importDefault(require("crypto-js"));
const store_1 = require("./store");
const getBaseUrl = async () => {
    const domain = await store_1.ConfigStore.domain();
    return `https://www.${domain || constants_1.DOMAINS.China}`;
};
exports.getBaseUrl = getBaseUrl;
const getApiBaseUrl = async () => {
    const domain = await store_1.ConfigStore.domain();
    return `https://api.${domain || constants_1.DOMAINS.China}`;
};
exports.getApiBaseUrl = getApiBaseUrl;
const getRequestHeaders = async (options = {}) => {
    const baseUrl = await (0, exports.getBaseUrl)();
    const headers = {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.5 Safari/605.1.15",
        Referer: baseUrl,
    };
    if (options.includesDnts) {
        headers["dnts"] = "1";
    }
    return headers;
};
exports.getRequestHeaders = getRequestHeaders;
const decryptString = (encryptedString, decryptionKey) => {
    try {
        const iv = encryptedString.substring(0, 16);
        const hexCiphertext = encryptedString.substring(16);
        // Use the provided key or fall back to the default key
        const keyString = decryptionKey || constants_1.DECRYPT_KEY;
        const key = crypto_js_1.default.enc.Utf8.parse(keyString);
        const ivBytes = crypto_js_1.default.enc.Utf8.parse(iv);
        const cipherParams = crypto_js_1.default.lib.CipherParams.create({
            ciphertext: crypto_js_1.default.enc.Hex.parse(hexCiphertext),
        });
        const decrypted = crypto_js_1.default.AES.decrypt(cipherParams, key, {
            iv: ivBytes,
            padding: crypto_js_1.default.pad.Pkcs7,
            mode: crypto_js_1.default.mode.CBC,
        });
        return decrypted.toString(crypto_js_1.default.enc.Utf8);
    }
    catch (error) {
        console.error("Decryption error:", error);
        throw new Error("Failed to decrypt data");
    }
};
exports.decryptString = decryptString;
// Parse search request to URL parameters
const parseSearchRequest = (request) => {
    const page = request.page ?? 1;
    const offset = (page - 1) * constants_1.LIMIT;
    const params = {
        limit: constants_1.LIMIT,
        offset,
    };
    if (request.query) {
        params.q = request.query;
    }
    if (request.filters) {
        const { theme, status, region } = request.filters;
        if (theme)
            params.theme = theme;
        if (status)
            params.status = status;
        if (region)
            params.region = region;
    }
    if (request.sort) {
        if (request.sort.ascending) {
            params.ordering = request.sort.id;
        }
        else {
            params.ordering = `-${request.sort.id}`;
        }
    }
    return params;
};
exports.parseSearchRequest = parseSearchRequest;
// Convert manga excerpt to highlight
const mangaToHighlight = (manga) => {
    return {
        id: manga.path_word,
        title: manga.name,
        cover: manga.cover.replace(".328x422.jpg", ""),
    };
};
exports.mangaToHighlight = mangaToHighlight;
// Convert manga list to page result
const mangaListToPageResult = (mangaList, hasMore) => {
    return {
        results: mangaList.map(exports.mangaToHighlight),
        isLastPage: !hasMore,
    };
};
exports.mangaListToPageResult = mangaListToPageResult;
// Convert status code to publication status
const convertStatus = (statusCode) => {
    switch (statusCode) {
        case types_1.Status.Ongoing:
            return daisuke_1.PublicationStatus.ONGOING;
        case types_1.Status.Completed:
        case types_1.Status.OneShot:
            return daisuke_1.PublicationStatus.COMPLETED;
        default:
            return daisuke_1.PublicationStatus.ONGOING; // Default to ONGOING if unknown
    }
};
exports.convertStatus = convertStatus;
const convertRegion = (region) => {
    switch (region) {
        case types_1.Region.Japan:
            return types_1.Region.Japan;
        case types_1.Region.Korea:
            return types_1.Region.Korea;
        case types_1.Region.West:
            return types_1.Region.West;
        default:
            return types_1.Region.Japan;
    }
};
exports.convertRegion = convertRegion;
const regionToDisplay = (region) => {
    switch (region) {
        case types_1.Region.Japan:
            return "日漫";
        case types_1.Region.Korea:
            return "韓漫";
        case types_1.Region.West:
            return "美漫";
        default:
            return "其它";
    }
};
exports.regionToDisplay = regionToDisplay;
const readingModeByRegion = (region) => {
    switch (region) {
        case types_1.Region.Japan:
            return daisuke_1.ReadingMode.PAGED_MANGA;
        case types_1.Region.Korea:
            return daisuke_1.ReadingMode.WEBTOON;
        case types_1.Region.West:
            return daisuke_1.ReadingMode.PAGED_COMIC;
        default:
            return daisuke_1.ReadingMode.PAGED_MANGA;
    }
};
exports.readingModeByRegion = readingModeByRegion;
// Parse chapter title to extract volume and chapter numbers
const parseChapterTitle = (chapterName, type) => {
    // If type is 3, don't parse, just return the title
    if (type === 3) {
        return {
            chapter: 0,
            title: chapterName,
        };
    }
    // Handle special cases first
    const trimmed = chapterName.trim();
    // Check for "全一X" patterns at the start
    if (trimmed.startsWith("全") && (trimmed[1] === "一" || trimmed[1] === "1")) {
        if (trimmed[2] === "卷" || trimmed[2] === "冊" || trimmed[2] === "册") {
            return {
                volume: 1,
                chapter: 0,
                title: chapterName,
            };
        }
        if (trimmed[2] === "話" || trimmed[2] === "话" || trimmed[2] === "回") {
            return {
                chapter: 1,
                title: chapterName,
            };
        }
    }
    const regex = /^(?<volume>第?(?<volume_num>[\d零一二三四五六七八九十百千]+(\.\d)?)[卷部季冊册]完?)?(?<chapter>(第|连载|CH)?(?<chapter_num>[\d零一二三四五六七八九十百千]+(\.\d+)?)(?<more_chapters>-(\d+(\.\d+)?))?[話话回]?)?([ +]|$)/;
    const match = regex.exec(trimmed);
    if (!match || !match.groups) {
        return {
            chapter: 0,
            title: chapterName,
        };
    }
    const getNumber = (str) => {
        if (!str)
            return;
        const chineseToArabic = {
            零: 0,
            一: 1,
            二: 2,
            三: 3,
            四: 4,
            五: 5,
            六: 6,
            七: 7,
            八: 8,
            九: 9,
            十: 10,
            百: 100,
            千: 1000,
        };
        const numericValue = parseFloat(str);
        if (!isNaN(numericValue)) {
            return numericValue;
        }
        let result = 0;
        let temp = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            const value = chineseToArabic[char];
            if (value >= 10) {
                result += (temp === 0 ? 1 : temp) * value;
                temp = 0;
            }
            else if (value !== undefined) {
                temp = value;
            }
        }
        return result + temp;
    };
    const volumeNum = getNumber(match.groups.volume_num);
    const chapterNum = getNumber(match.groups.chapter_num);
    // Remove matched parts from the title
    let realTitle = trimmed;
    if (match.groups.volume) {
        realTitle = realTitle.replace(match.groups.volume, "");
    }
    if (!match.groups.more_chapters && match.groups.chapter) {
        realTitle = realTitle.replace(match.groups.chapter, "");
    }
    realTitle = realTitle.trim();
    return {
        volume: volumeNum,
        chapter: chapterNum ?? 0,
        title: realTitle || chapterName,
    };
};
exports.parseChapterTitle = parseChapterTitle;
// Get timestamp from UUID
// example: 43acc6f8-5d5d-11ee-9412-d3d228a76de6
const getTimestampFromUuid = (uuid) => {
    // UUID v1 format: time_low-time_mid-time_hi_and_version-clock_seq-node
    // Extract the time components
    const parts = uuid.split("-");
    if (parts.length !== 5) {
        throw new Error("Invalid UUID format");
    }
    // Extract time components (time_low, time_mid, time_hi_and_version)
    const timeLow = parseInt(parts[0], 16);
    const timeMid = parseInt(parts[1], 16);
    const timeHiAndVersion = parseInt(parts[2], 16) & 0x0fff; // Remove version bits
    // Combine time components into a 60-bit timestamp
    // Convert to BigInt to handle large numbers
    const timestamp = (BigInt(timeHiAndVersion) << 48n) |
        (BigInt(timeMid) << 32n) |
        BigInt(timeLow);
    // Convert to Unix timestamp (seconds since epoch)
    // UUID timestamp is 100-nanosecond intervals since October 15, 1582
    // Need to convert to Unix epoch (January 1, 1970)
    const UNIX_EPOCH_DIFF = 122192928000000000n; // Difference in 100ns intervals
    // Calculate Unix timestamp in 100ns intervals
    const unixTimestamp100Ns = timestamp - UNIX_EPOCH_DIFF;
    const seconds = Number(unixTimestamp100Ns / 10000000n);
    const fraction = Number(unixTimestamp100Ns % 10000000n) / 10000000;
    return seconds + fraction;
};
exports.getTimestampFromUuid = getTimestampFromUuid;
// Convert chapter groups to chapters array
const chapterGroupsToChapters = async (groups, mangaId) => {
    const allChapters = [];
    const baseUrl = await (0, exports.getBaseUrl)();
    Object.values(groups).forEach((group) => {
        const groupName = group.name;
        group.chapters.forEach((chapter) => {
            const chapterId = chapter.id;
            try {
                const timestamp = (0, exports.getTimestampFromUuid)(chapterId);
                allChapters.push({
                    chapterId,
                    chapterName: chapter.name,
                    chapterType: chapter.type,
                    timestamp,
                    groupName,
                });
            }
            catch (error) {
                console.error(`Error processing chapter ${chapterId}:`, error);
            }
        });
    });
    allChapters.sort((a, b) => b.timestamp - a.timestamp);
    return allChapters.map((chapterInfo, index) => {
        // Parse the chapter name to extract volume/chapter numbers
        const part = (0, exports.parseChapterTitle)(chapterInfo.chapterName, chapterInfo.chapterType);
        // Create the final title with group prefix if not default group
        const titlePrefix = chapterInfo.groupName === "默認" ? "" : `${chapterInfo.groupName}：`;
        const finalTitle = part.title
            ? `${titlePrefix}${part.title}`
            : `${titlePrefix}${chapterInfo.chapterName}`;
        return {
            id: chapterInfo.chapterId,
            chapterId: chapterInfo.chapterId,
            title: finalTitle,
            number: part.chapter,
            volume: part.volume,
            date: new Date(chapterInfo.timestamp * 1000),
            index,
            language: "zh",
            ...(chapterInfo.groupName !== "默認" && {
                providers: [{ id: chapterInfo.groupName, name: chapterInfo.groupName }],
            }),
            contentId: mangaId,
            url: `${baseUrl}/comic/${mangaId}/chapter/${chapterInfo.chapterId}`,
        };
    });
};
exports.chapterGroupsToChapters = chapterGroupsToChapters;
// API URL generators
const generateExploreUrl = async (theme, top, ordering, page) => {
    const baseUrl = await (0, exports.getBaseUrl)();
    return `${baseUrl}/comics?theme=${theme}&top=${top}&ordering=${ordering}&limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateExploreUrl = generateExploreUrl;
const getSearchApiEndpoint = async () => {
    const baseUrl = await (0, exports.getBaseUrl)();
    const searchPageUrl = `${baseUrl}/search`;
    const headers = await (0, exports.getRequestHeaders)();
    const client = new NetworkClient();
    const response = await client.get(searchPageUrl, { headers });
    // Extract the API endpoint from the search page
    const match = response.data.match(/const countApi = "([^"]+)"/);
    if (!match || !match[1]) {
        throw new Error("Failed to extract search API endpoint");
    }
    return match[1];
};
exports.getSearchApiEndpoint = getSearchApiEndpoint;
const generateSearchUrl = async (query, page) => {
    const searchApi = await (0, exports.getSearchApiEndpoint)();
    return `${searchApi}?q=${encodeURIComponent(query)}&platform=2&limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}&q_type=`;
};
exports.generateSearchUrl = generateSearchUrl;
const generateRankUrl = async (dateType, page) => {
    const baseUrl = await (0, exports.getApiBaseUrl)();
    return `${baseUrl}/api/v3/ranks?date_type=${dateType}&limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateRankUrl = generateRankUrl;
const generateRecsUrl = async (page) => {
    const baseUrl = await (0, exports.getApiBaseUrl)();
    return `${baseUrl}/api/v3/recs?pos=3200102&limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateRecsUrl = generateRecsUrl;
const generateNewestUrl = async (page) => {
    const baseUrl = await (0, exports.getApiBaseUrl)();
    return `${baseUrl}/api/v3/update/newest?limit=${constants_1.LIMIT}&offset=${(page - 1) * constants_1.LIMIT}`;
};
exports.generateNewestUrl = generateNewestUrl;
const generateMangaDetailsUrl = async (id) => {
    const baseUrl = await (0, exports.getBaseUrl)();
    return `${baseUrl}/comic/${id}`;
};
exports.generateMangaDetailsUrl = generateMangaDetailsUrl;
const generateChapterListUrl = async (id) => {
    const baseUrl = await (0, exports.getBaseUrl)();
    return `${baseUrl}/comicdetail/${id}/chapters`;
};
exports.generateChapterListUrl = generateChapterListUrl;
const generatePageListUrl = async (mangaId, chapterId) => {
    const baseUrl = await (0, exports.getBaseUrl)();
    return `${baseUrl}/comic/${mangaId}/chapter/${chapterId}`;
};
exports.generatePageListUrl = generatePageListUrl;
// Check if the API response has more pages
const hasMorePages = (data) => {
    const total = data.total || 0;
    const offset = data.offset || 0;
    const limit = data.limit || constants_1.LIMIT;
    return offset + limit < total;
};
exports.hasMorePages = hasMorePages;

},{"./constants":1,"./store":3,"./types":4,"@suwatte/daisuke":6,"crypto-js":undefined}],6:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./runners"), exports);
__exportStar(require("./types"), exports);

},{"./runners":30,"./types":60}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],8:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],9:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],10:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],11:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],12:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],13:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],14:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],15:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],16:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ContentEvent"), exports);
__exportStar(require("./ChapterEvent"), exports);
__exportStar(require("./ProgressSync"), exports);
__exportStar(require("./LibrarySync"), exports);
__exportStar(require("./StreamContextProvider"), exports);
__exportStar(require("./ContextMenuHandler"), exports);
__exportStar(require("./GroupedUpdateProvider"), exports);
__exportStar(require("./ImageRedrawHandler"), exports);

},{"./ChapterEvent":8,"./ContentEvent":9,"./ContextMenuHandler":10,"./GroupedUpdateProvider":11,"./ImageRedrawHandler":12,"./LibrarySync":13,"./ProgressSync":14,"./StreamContextProvider":15}],17:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./handlers"), exports);
__exportStar(require("./ContentSource"), exports);

},{"./ContentSource":7,"./handlers":16}],18:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],19:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],20:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ContentTracker"), exports);
__exportStar(require("./AdvancedTracker"), exports);

},{"./AdvancedTracker":18,"./ContentTracker":19}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicAuthenticationUIIdentifier = void 0;
var BasicAuthenticationUIIdentifier;
(function (BasicAuthenticationUIIdentifier) {
    BasicAuthenticationUIIdentifier[BasicAuthenticationUIIdentifier["EMAIL"] = 0] = "EMAIL";
    BasicAuthenticationUIIdentifier[BasicAuthenticationUIIdentifier["USERNAME"] = 1] = "USERNAME";
})(BasicAuthenticationUIIdentifier || (exports.BasicAuthenticationUIIdentifier = BasicAuthenticationUIIdentifier = {}));

},{}],22:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],23:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],24:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],25:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],26:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],27:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],28:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Authentication"), exports);
__exportStar(require("./Preferences"), exports);
__exportStar(require("./ImageRequest"), exports);
__exportStar(require("./DirectoryHandler"), exports);
__exportStar(require("./PageProvider"), exports);
__exportStar(require("./Setup"), exports);
__exportStar(require("./PageResolver"), exports);

},{"./Authentication":21,"./DirectoryHandler":22,"./ImageRequest":23,"./PageProvider":24,"./PageResolver":25,"./Preferences":26,"./Setup":27}],29:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunnerEnvironment = void 0;
__exportStar(require("./extensions"), exports);
var RunnerEnvironment;
(function (RunnerEnvironment) {
    RunnerEnvironment[RunnerEnvironment["SOURCE"] = 0] = "SOURCE";
    RunnerEnvironment[RunnerEnvironment["TRACKER"] = 1] = "TRACKER";
})(RunnerEnvironment || (exports.RunnerEnvironment = RunnerEnvironment = {}));

},{"./extensions":28}],30:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ContentSource"), exports);
__exportStar(require("./Runner"), exports);
__exportStar(require("./ContentTracker"), exports);

},{"./ContentSource":17,"./ContentTracker":20,"./Runner":29}],31:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],32:[function(require,module,exports){
"use strict";
// Picker
Object.defineProperty(exports, "__esModule", { value: true });

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIStepper = exports.UIButton = exports.UIDatePicker = exports.UITextField = exports.UIToggle = exports.UIMultiPicker = exports.UIPicker = void 0;
const UIElements_1 = require("./UIElements");
const UIPicker = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.SELECT }));
exports.UIPicker = UIPicker;
const UIMultiPicker = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.MULTISELECT }));
exports.UIMultiPicker = UIMultiPicker;
const UIToggle = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.TOGGLE }));
exports.UIToggle = UIToggle;
const UITextField = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.TEXTFIELD }));
exports.UITextField = UITextField;
const UIDatePicker = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.DATEPICKER }));
exports.UIDatePicker = UIDatePicker;
const UIButton = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.BUTTON }));
exports.UIButton = UIButton;
const UIStepper = (props) => (Object.assign(Object.assign({}, props), { type: UIElements_1.UIComponentType.STEPPER }));
exports.UIStepper = UIStepper;

},{"./UIElements":34}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIComponentType = void 0;
var UIComponentType;
(function (UIComponentType) {
    UIComponentType[UIComponentType["SELECT"] = 0] = "SELECT";
    UIComponentType[UIComponentType["MULTISELECT"] = 1] = "MULTISELECT";
    UIComponentType[UIComponentType["STEPPER"] = 2] = "STEPPER";
    UIComponentType[UIComponentType["TOGGLE"] = 3] = "TOGGLE";
    UIComponentType[UIComponentType["TEXTFIELD"] = 4] = "TEXTFIELD";
    UIComponentType[UIComponentType["BUTTON"] = 5] = "BUTTON";
    UIComponentType[UIComponentType["DATEPICKER"] = 6] = "DATEPICKER";
})(UIComponentType || (exports.UIComponentType = UIComponentType = {}));

},{}],35:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Form"), exports);
__exportStar(require("./UIElements"), exports);
__exportStar(require("./UIDefinitions"), exports);
__exportStar(require("./UIElementBuilders"), exports);

},{"./Form":31,"./UIDefinitions":32,"./UIElementBuilders":33,"./UIElements":34}],36:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefinedLanguages = void 0;
var DefinedLanguages;
(function (DefinedLanguages) {
    DefinedLanguages["UNIVERSAL"] = "UNIVERSAL";
    DefinedLanguages["ENGLISH"] = "en_US";
    DefinedLanguages["KOREAN"] = "ko_KR";
    DefinedLanguages["JAPANESE"] = "ja_JP";
    DefinedLanguages["FRENCH"] = "fr_FR";
    DefinedLanguages["CHINESE"] = "zh-CN";
    DefinedLanguages["SPANISH"] = "es_ES";
    DefinedLanguages["PORTUGUESE"] = "pt_BR";
})(DefinedLanguages || (exports.DefinedLanguages = DefinedLanguages = {}));

},{}],38:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],39:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],40:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],41:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],42:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],43:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentType = exports.ReadingFlag = exports.ReadingMode = exports.PublicationStatus = void 0;
// Enums
var PublicationStatus;
(function (PublicationStatus) {
    PublicationStatus[PublicationStatus["ONGOING"] = 1] = "ONGOING";
    PublicationStatus[PublicationStatus["COMPLETED"] = 2] = "COMPLETED";
    PublicationStatus[PublicationStatus["CANCELLED"] = 3] = "CANCELLED";
    PublicationStatus[PublicationStatus["HIATUS"] = 4] = "HIATUS";
})(PublicationStatus || (exports.PublicationStatus = PublicationStatus = {}));
/**
 * The method in which the content can be read
 */
var ReadingMode;
(function (ReadingMode) {
    ReadingMode[ReadingMode["PAGED_MANGA"] = 0] = "PAGED_MANGA";
    ReadingMode[ReadingMode["PAGED_COMIC"] = 1] = "PAGED_COMIC";
    ReadingMode[ReadingMode["PAGED_VERTICAL"] = 2] = "PAGED_VERTICAL";
    ReadingMode[ReadingMode["WEBTOON"] = 3] = "WEBTOON";
})(ReadingMode || (exports.ReadingMode = ReadingMode = {}));
var ReadingFlag;
(function (ReadingFlag) {
    ReadingFlag[ReadingFlag["READING"] = 0] = "READING";
    ReadingFlag[ReadingFlag["PLANNED"] = 1] = "PLANNED";
    ReadingFlag[ReadingFlag["COMPLETED"] = 2] = "COMPLETED";
    ReadingFlag[ReadingFlag["DROPPED"] = 3] = "DROPPED";
    ReadingFlag[ReadingFlag["REREADING"] = 4] = "REREADING";
    ReadingFlag[ReadingFlag["PAUSED"] = 5] = "PAUSED";
    ReadingFlag[ReadingFlag["UNKNOWN"] = 6] = "UNKNOWN";
})(ReadingFlag || (exports.ReadingFlag = ReadingFlag = {}));
var ContentType;
(function (ContentType) {
    ContentType[ContentType["MANGA"] = 0] = "MANGA";
    ContentType[ContentType["MANHUA"] = 1] = "MANHUA";
    ContentType[ContentType["MANHWA"] = 2] = "MANHWA";
    ContentType[ContentType["COMIC"] = 3] = "COMIC";
    ContentType[ContentType["NOVEL"] = 4] = "NOVEL";
})(ContentType || (exports.ContentType = ContentType = {}));

},{}],45:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],46:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],47:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderLinkType = void 0;
var ProviderLinkType;
(function (ProviderLinkType) {
    ProviderLinkType[ProviderLinkType["WEBSITE"] = 0] = "WEBSITE";
    ProviderLinkType[ProviderLinkType["TWITTER"] = 1] = "TWITTER";
    ProviderLinkType[ProviderLinkType["DISCORD"] = 2] = "DISCORD";
    ProviderLinkType[ProviderLinkType["PATREON"] = 3] = "PATREON";
})(ProviderLinkType || (exports.ProviderLinkType = ProviderLinkType = {}));

},{}],49:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],50:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Content"), exports);
__exportStar(require("./Highlight"), exports);
__exportStar(require("./Chapter"), exports);
__exportStar(require("./ChapterData"), exports);
__exportStar(require("./Property"), exports);
__exportStar(require("./Collection"), exports);
__exportStar(require("./Provider"), exports);
__exportStar(require("./Enums"), exports);
__exportStar(require("./ReaderContext"), exports);
__exportStar(require("./ContextMenu"), exports);
__exportStar(require("./DeepLinkContext"), exports);
__exportStar(require("./BooleanState"), exports);
__exportStar(require("./ContentProgressState"), exports);
__exportStar(require("./GroupedUpdatesResponse"), exports);

},{"./BooleanState":36,"./Chapter":37,"./ChapterData":38,"./Collection":39,"./Content":40,"./ContentProgressState":41,"./ContextMenu":42,"./DeepLinkContext":43,"./Enums":44,"./GroupedUpdatesResponse":45,"./Highlight":46,"./Property":47,"./Provider":48,"./ReaderContext":49}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthMethod = void 0;
var AuthMethod;
(function (AuthMethod) {
    AuthMethod[AuthMethod["USERNAME_PW"] = 0] = "USERNAME_PW";
    AuthMethod[AuthMethod["EMAIL_PW"] = 1] = "EMAIL_PW";
    AuthMethod[AuthMethod["WEB"] = 2] = "WEB";
    AuthMethod[AuthMethod["OAUTH"] = 3] = "OAUTH";
})(AuthMethod || (exports.AuthMethod = AuthMethod = {}));

},{}],52:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],53:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CatalogRating = void 0;
var CatalogRating;
(function (CatalogRating) {
    /**
     * Catalog does not contain ANY SUGGESTIVE OR NSFW content
     */
    CatalogRating[CatalogRating["SAFE"] = 0] = "SAFE";
    /**
     * Catalog may contain SUGGESTIVE OR NSFW content,
     * runners must hide NSFW content by default,
     * users will be required to verify they are of age to view NSFW content
     */
    CatalogRating[CatalogRating["MIXED"] = 1] = "MIXED";
    /**
     * Catalog contains MAINLY SUGGESTIVE OR NSFW content,
     * users will be required to verify they are of age to view NSFW content
     */
    CatalogRating[CatalogRating["NSFW"] = 2] = "NSFW";
})(CatalogRating || (exports.CatalogRating = CatalogRating = {}));

},{}],55:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Authentication"), exports);
__exportStar(require("./RunnerInfo"), exports);
__exportStar(require("./PagedResult"), exports);
__exportStar(require("./ContextProvider"), exports);

},{"./Authentication":51,"./ContextProvider":52,"./PagedResult":53,"./RunnerInfo":54}],56:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterType = void 0;
var FilterType;
(function (FilterType) {
    /**
     * This Represents the filter as a toggle switch, the value returned in the directory request will be a `boolean`
     */
    FilterType[FilterType["TOGGLE"] = 0] = "TOGGLE";
    /**
     * This represents the filter as a picker, the value returned will be the `key` of the selected option as a `string`
     */
    FilterType[FilterType["SELECT"] = 1] = "SELECT";
    /**
     * This Represents the filter as a multi-picker, the value returned will the the keys of the selected options as an array of strings
     */
    FilterType[FilterType["MULTISELECT"] = 2] = "MULTISELECT";
    /**
     * This Represents the filter as a multi-picker,the value returned will be of type {@link ExcludableMultiSelectProp}
     */
    FilterType[FilterType["EXCLUDABLE_MULTISELECT"] = 3] = "EXCLUDABLE_MULTISELECT";
    /**
     * This will represent the filter as a textfield, the value returned will be a string
     */
    FilterType[FilterType["TEXT"] = 4] = "TEXT";
    /**
     * This is a basic filter that will only display the title or subtitle, it will not return any value in the populated `DirectoryRequest`
     */
    FilterType[FilterType["INFO"] = 5] = "INFO";
})(FilterType || (exports.FilterType = FilterType = {}));

},{}],58:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],59:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./DirectoryConfig"), exports);
__exportStar(require("./DirectoryRequest"), exports);
__exportStar(require("./DirectoryFilter"), exports);

},{"./DirectoryConfig":56,"./DirectoryFilter":57,"./DirectoryRequest":58}],60:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generate = void 0;
__exportStar(require("./core"), exports);
__exportStar(require("./content"), exports);
__exportStar(require("./networking"), exports);
__exportStar(require("./UI"), exports);
__exportStar(require("./tracker"), exports);
__exportStar(require("./directory"), exports);
__exportStar(require("./page"), exports);
const Generate = (v) => v;
exports.Generate = Generate;

},{"./UI":35,"./content":50,"./core":55,"./directory":59,"./networking":67,"./page":68,"./tracker":69}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkClientBuilder = void 0;
/**
 * NetworkClientBuilder is a builder class used for creating and configuring instances of NetworkClient.
 * The builder allows you to configure various aspects of the NetworkClient, such as rate limits,
 * request/response transformers (interceptors), headers, cookies, timeout, status validator, and more.
 */
class NetworkClientBuilder {
    constructor() {
        // Array of functions that transform requests
        this.requestTransformers = [];
        // Array of functions that transform responses
        this.responseTransformers = [];
        // Object representing HTTP headers, where each key-value pair represents a header
        this.headers = {};
        // Array of cookies
        this.cookies = [];
    }
    /**
     * Sets the rate limit for the NetworkClient.
     *
     * @param requests - The maximum number of requests to make per interval.
     * @param interval - The length of the rate limiting interval in seconds.
     * @returns The builder, to allow for method chaining.
     */
    setRateLimit(requests, interval) {
        this.requestsPerSecond = requests / interval;
        return this;
    }
    /**
     * Adds a request interceptor to the NetworkClient.
     *
     * @param transformer - The interceptor to add. This should be a function that takes a request and modifies it in some way.
     * @returns The builder, to allow for method chaining.
     */
    addRequestInterceptor(transformer) {
        this.requestTransformers.push(transformer);
        return this;
    }
    /**
     * Adds a response interceptor to the NetworkClient.
     *
     * @param transformer - The interceptor to add. This should be a function that takes a response and modifies it in some way.
     * @returns The builder, to allow for method chaining.
     */
    addResponseInterceptor(transformer) {
        this.responseTransformers.push(transformer);
        return this;
    }
    /**
     * Sets the authorization token for the NetworkClient.
     *
     * @param token - The token to be included in the Authorization header of every request.
     * @returns The builder, to allow for method chaining.
     */
    setAuthorizationToken(token) {
        return this.addHeader("Authorization", token);
    }
    /**
     * Sets the status validator for the NetworkClient.
     *
     * @param validator - A function that takes a status code and returns true if it is considered successful.
     * @returns The builder, to allow for method chaining.
     */
    setStatusValidator(validator) {
        this.statusValidator = validator;
        return this;
    }
    /**
     * Sets the timeout for requests made by the NetworkClient.
     *
     * @param timeout - The maximum time to wait for a request to complete, in milliseconds.
     * @returns The builder, to allow for method chaining.
     */
    setTimeout(timeout) {
        this.timeout = timeout;
        return this;
    }
    /**
     * Sets the maximum number of retries for this request by the NetworkClient.
     *
     * @param retries - The maximum number of retries for this request
     * @returns The builder, to allow for method chaining.
     */
    setMaxRetries(retries) {
        this.maxRetries = retries;
        return this;
    }
    /**
     * Sets a header for the NetworkClient.
     *
     * @param key - The name of the header
     * @param value - The value of the header
     * @returns The builder, to allow for method chaining.
     */
    addHeader(key, value) {
        this.headers[key] = value;
        return this;
    }
    /**
     * Sets a cookie for the NetworkClient.
     *
     * @param cookie - The cookie to be included in every request.
     * @returns The builder, to allow for method chaining.
     */
    addCookie(cookie) {
        this.cookies.push(cookie);
        return this;
    }
    /**
     * Builds a NetworkClient using the parameters set on the builder.
     *
     * @returns A NetworkClient with the configured parameters.
     */
    build() {
        return new NetworkClient(this);
    }
}
exports.NetworkClientBuilder = NetworkClientBuilder;

},{}],62:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],63:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],64:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.name = void 0;
const name = (base, known) => __awaiter(void 0, void 0, void 0, function* () {
    return Object.assign(Object.assign({}, base), known);
});
exports.name = name;

},{}],65:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],66:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],67:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Builder"), exports);
__exportStar(require("./Client"), exports);
__exportStar(require("./Request"), exports);
__exportStar(require("./Response"), exports);
__exportStar(require("./Transformer"), exports);
__exportStar(require("./Error"), exports);

},{"./Builder":61,"./Client":62,"./Error":63,"./Request":64,"./Response":65,"./Transformer":66}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SectionStyle = void 0;
var SectionStyle;
(function (SectionStyle) {
    SectionStyle[SectionStyle["DEFAULT"] = 0] = "DEFAULT";
    SectionStyle[SectionStyle["INFO"] = 1] = "INFO";
    SectionStyle[SectionStyle["GALLERY"] = 2] = "GALLERY";
    SectionStyle[SectionStyle["NAVIGATION_LIST"] = 3] = "NAVIGATION_LIST";
    SectionStyle[SectionStyle["ITEM_LIST"] = 4] = "ITEM_LIST";
    SectionStyle[SectionStyle["PADDED_LIST"] = 5] = "PADDED_LIST";
    SectionStyle[SectionStyle["TAG"] = 6] = "TAG";
    SectionStyle[SectionStyle["STANDARD_GRID"] = 7] = "STANDARD_GRID";
})(SectionStyle || (exports.SectionStyle = SectionStyle = {}));

},{}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackStatus = void 0;
var TrackStatus;
(function (TrackStatus) {
    TrackStatus["READING"] = "READING";
    TrackStatus["PLANNING"] = "PLANNING";
    TrackStatus["COMPLETED"] = "COMPLETED";
    TrackStatus["PAUSED"] = "PAUSED";
    TrackStatus["DROPPED"] = "DROPPED";
    TrackStatus["REREADING"] = "REREADING";
})(TrackStatus || (exports.TrackStatus = TrackStatus = {}));

},{}]},{},[2])(2)
});
